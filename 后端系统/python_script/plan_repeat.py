import requests
import sys
import argparse
import pymysql
import pandas as pd
from datetime import datetime
from json_repair import repair_json
# 使用 argparse 解析命令行参数
parser = argparse.ArgumentParser(description="接收 Node.js 传入的参数")
parser.add_argument('--id', type=int, help='ID')
parser.add_argument('--skill_id', type=int, help='skill_id')
parser.add_argument('--skill', type=str, help='skill')
parser.add_argument('--path_id', type=int, help='path_id')


args = parser.parse_args()

id=args.id
skill_id=args.skill_id
path_id=args.path_id
skill=args.skill

def calculate_overlap(str1, str2):
    
    str1=str1.upper()
    str2=str2.upper()
    # 将字符串转换为字符集合
    set1 = set(str1)
    set2 = set(str2)
    
    # 计算交集（重合字符）
    overlap_chars = set1 & set2
    overlap_count = len(overlap_chars)
    
    # 计算并集（总字符数，去重）
    total_chars = set1 | set2
    total_count = len(total_chars)
    
    # 计算重合度（避免除以零）
    if total_count == 0:
        similarity = 0.0
    else:
        similarity = overlap_count * 2 / total_count
    
    return similarity, overlap_count, total_count

id2skill={"54":"微积分","86":"向量空间","1":"拓扑方法","13":"矩阵乘法","346":"坐标轴","277":"组合数","279":"素数","48":"几何学","280":"正实数","312":"初始相位","325":"切线","371":"向量投影","18":"对称性","70":"投影","79":"幂运算","276":"二项式定理","338":"平面图","83":"上界","310":"椭圆曲线","311":"圆锥","22":"分形","50":"未知数","278":"阶乘","75":"因式","305":"二次收敛","61":"数学物理","340":"位似变换","322":"分部积分法","27":"基底","40":"无限循环小数","49":"锥曲面与球面","363":"QR分解","34":"系数","42":"幂次","67":"函数复合","4":"平方根","81":"同构","77":"二次方程","82":"定义域","358":"标准差","47":"因式分解","46":"零点","296":"齐次函数","324":"参数方程","334":"四面体","336":"三角形","350":"开区间","309":"极值点","378":"向量内积","103":"孤点","65":"群论","15":"标量λ","326":"梯度","366":"内积","356":"几何-调和平均数","95":"弱分离公理","25":"微分方程","51":"函数","84":"正交群","26":"阶数","39":"进位制","294":"矩阵逆","297":"线性函数","301":"反函数","368":"共轭转置","21":"固定点","295":"指数函数","8":"多项式","36":"数的分割","80":"子广群","287":"求和符号","314":"角频率","331":"拉格朗日","302":"分数指数","307":"最佳多项式","333":"柯西","392":"凹凸性","17":"变换","12":"矩阵","11":"余弦函数","16":"向量","74":"一次函数","298":"多元实函数","106":"邻域","240":"无穷级数","299":"复数空间","217":"三维正交坐标系","308":"一阶导数","166":"闭开集","317":"二项式展开","288":"二项式系数的求和公式","523":"有向曲面","303":"极限集合","230":"数学集合理论","354":"连续函数的闭支撑","35":"整数加法","306":"收敛速度","58":"古典力学","202":"双曲线","323":"连续可导函数","78":"乘法","304":"不动点理论","110":"拓扑空间","362":"直角坐标系","316":"二阶导数","85":"判别式","69":"逆矩阵","5":"代数","360":"调和平均数","365":"正交矩阵","393":"容积","2":"单位根","9":"指数运算","10":"常数项","319":"可导性","339":"科学计数法","361":"单位圆","391":"平面几何","231":"数域包含关系","6":"模运算","24":"线性","284":"三角函数","281":"向量加法","63":"子群","282":"三线坐标","321":"乘积法则","32":"线性外代数","283":"共线","224":"正实数集合","62":"狭义相对论","222":"复数域","204":"圆锥坐标系","238":"级数的项","209":"圆球面","172":"鞍点","6868":"几何体","10466":"实数","925":"无穷小量","504":"极限","10467":"等式","3996":"等比级数","1543":"无穷","490":"有理数","10468":"实数系","425":"收敛定理","5368":"闭区间","5298":"基数","10469":"拓扑学","10470":"位置数字系统","2585":"标准实数系统","10471":"小数展开式","464":"数论","9950":"10进数","10472":"小数点","4019":"算术","2548":"柯西序列","10473":"戴德金分割","10474":"不定式","1627":"无限小数","5348":"排列组合","3951":"空函数","10475":"集合论中的指数运算","10476":"幂次法则","10477":"零次幂","10478":"常数函数","4983":"零函数","10479":"零次函数","3954":"空集","3492":"水平线","10480":"一元运算","4730":"超越数","10481":"多项式函数","559":"泰勒级数","10482":"微分规则","10483":"逐项微分","10484":"级数","6916":"几何级数","7252":"切比雪夫多项式","5088":"首项系数","560":"泰勒展开","10485":"误差余项","10486":"e^x","5299":"复数","575":"无理数","5207":"代数数","1777":"映射(函数)","10487":"转置","4974":"集合","8647":"合成关系","6867":"几何代数","6737":"关系合成","1307":"整数集(Z)","5316":"子集","8145":"双曲几何","10488":"直线","5772":"互自切点(tacnode)","10489":"等边五边形","10490":"射线","6946":"凸五边形镶嵌","10491":"线段","557":"法线","10492":"矢","1914":"最值点","4497":"角平分线","5287":"圆","1011":"摆线","9407":"垂直平分线","8745":"同界角","5841":"五边形镶嵌","10493":"平行","10494":"四维柱体柱","1450":"旋转","8450":"可展曲面","4173":"球面几何","5160":"三维空间","5655":"二维空间","10495":"直纹曲面","10496":"一维空间","6120":"体积","5003":"长度","8925":"周长","10497":"对称轴","3351":"正方形","581":"曲线","3962":"立方体","9402":"垂直","6458":"克莱因瓶","10498":"相交","10499":"相切","10500":"相离","10501":"镜像","8296":"反演","10502":"表面积","10503":"挠率","4500":"角度","10504":"面积","10505":"离心率","10506":"三角函数表","3321":"正弦曲线","10507":"cis","10508":"三分之一角公式","10509":"三角函数恒等式","10510":"三角多项式","8135":"双曲三角函数","5266":"反三角函数","10511":"诱导公式","7714":"半正矢公式","10512":"三角函数精确值","5098":"高斯函数","10513":"三角函数积分表","5270":"双曲函数","10514":"三角函数线","491":"有理函数","677":"无理函数","3319":"正弦平方","7393":"割圆八线","5214":"余弦定理","9260":"圆心角","8909":"周期性","6137":"余函数恒等式","7715":"半正矢定理","10515":"精确值","6138":"余切","515":"根号","10516":"tan","10517":"近似作图","554":"比例","3311":"正弦","10518":"π","10519":"绝对误差","6462":"克莱姆法则","7751":"协方差矩阵","5296":"基","546":"正交","5352":"特征值","2624":"标量","8819":"向量子空间","5353":"特征向量","4227":"线性方程组","10520":"对偶空间","7297":"列空间","4222":"线性投影","10521":"矩阵中的项","8143":"双曲余弦函数","10522":"矩阵中的Q元素","5221":"偏导数","8161":"双曲正弦函数","10523":"Lax对","544":"正弦函数","9637":"复共轭矩阵","10524":"高维Lax对","2311":"本征值","499":"李代数","2312":"本征向量","4606":"费马小定理","10525":"幺正矩阵","2417":"极分解","10526":"方块矩阵","10527":"奇异值分解","5683":"二重向量","10528":"克利福德代数","10529":"幂零矩阵","10530":"LU分解","3936":"稀疏矩阵","4419":"行列式","2733":"格拉姆-施密特正交化","7763":"单位上三角矩阵","10531":"非奇异方阵","5154":"三角矩阵","6040":"伴随矩阵","8263":"反对称矩阵","5277":"可逆矩阵","9441":"埃尔米特矩阵","3910":"秩","10532":"外积","2681":"核","4938":"迹","4105":"线性空间","9043":"四元数","10533":"多重积分","10534":"左反函数","5691":"二阶可导的凸函数","5143":"一元函数","5245":"凸函数","5194":"二次函数","10535":"一元可微函数","5551":"二次可微函数","5329":"导数","5246":"凸集","4351":"绝对值函数","10536":"严格凸函数","7711":"半正定","507":"极小值","5056":"黑塞矩阵","7077":"函数限制","10537":"一对一函数","5275":"可测函数","6404":"光滑函数","9670":"复合函数","3958":"空间变换","10538":"非满射函数","1386":"方程式根","6260":"偏函数","10539":"恒等函数","4920":"连续函数"}
skill2id={"微积分":"54","向量空间":"86","拓扑方法":"1","矩阵乘法":"13","坐标轴":"346","组合数":"277","素数":"279","几何学":"48","正实数":"280","初始相位":"312","切线":"325","向量投影":"371","对称性":"18","投影":"70","幂运算":"79","二项式定理":"276","平面图":"338","上界":"83","椭圆曲线":"310","圆锥":"311","分形":"22","未知数":"50","阶乘":"278","因式":"75","二次收敛":"305","数学物理":"61","位似变换":"340","分部积分法":"322","基底":"27","无限循环小数":"40","锥曲面与球面":"49","QR分解":"363","系数":"34","幂次":"42","函数复合":"67","平方根":"4","同构":"81","二次方程":"77","定义域":"82","标准差":"358","因式分解":"47","零点":"46","齐次函数":"296","参数方程":"324","四面体":"334","三角形":"336","开区间":"350","极值点":"309","向量内积":"378","孤点":"103","群论":"65","标量λ":"15","梯度":"326","内积":"366","几何-调和平均数":"356","弱分离公理":"95","微分方程":"25","函数":"51","正交群":"84","阶数":"26","进位制":"39","矩阵逆":"294","线性函数":"297","反函数":"301","共轭转置":"368","固定点":"21","指数函数":"295","多项式":"8","数的分割":"36","子广群":"80","求和符号":"287","角频率":"314","拉格朗日":"331","分数指数":"302","最佳多项式":"307","柯西":"333","凹凸性":"392","变换":"17","矩阵":"12","余弦函数":"11","向量":"16","一次函数":"74","多元实函数":"298","邻域":"106","无穷级数":"240","复数空间":"299","三维正交坐标系":"217","一阶导数":"308","闭开集":"166","二项式展开":"317","二项式系数的求和公式":"288","有向曲面":"523","极限集合":"303","数学集合理论":"230","连续函数的闭支撑":"354","整数加法":"35","收敛速度":"306","古典力学":"58","双曲线":"202","连续可导函数":"323","乘法":"78","不动点理论":"304","拓扑空间":"110","直角坐标系":"362","二阶导数":"316","判别式":"85","逆矩阵":"69","代数":"5","调和平均数":"360","正交矩阵":"365","容积":"393","单位根":"2","指数运算":"9","常数项":"10","可导性":"319","科学计数法":"339","单位圆":"361","平面几何":"391","数域包含关系":"231","模运算":"6","线性":"24","三角函数":"284","向量加法":"281","子群":"63","三线坐标":"282","乘积法则":"321","线性外代数":"32","共线":"283","正实数集合":"224","狭义相对论":"62","复数域":"222","圆锥坐标系":"204","级数的项":"238","圆球面":"209","鞍点":"172","几何体":"6868","实数":"10466","无穷小量":"925","极限":"504","等式":"10467","等比级数":"3996","无穷":"1543","有理数":"490","实数系":"10468","收敛定理":"425","闭区间":"5368","基数":"5298","拓扑学":"10469","位置数字系统":"10470","标准实数系统":"2585","小数展开式":"10471","数论":"464","10进数":"9950","小数点":"10472","算术":"4019","柯西序列":"2548","戴德金分割":"10473","不定式":"10474","无限小数":"1627","排列组合":"5348","空函数":"3951","集合论中的指数运算":"10475","幂次法则":"10476","零次幂":"10477","常数函数":"10478","零函数":"4983","零次函数":"10479","空集":"3954","水平线":"3492","一元运算":"10480","超越数":"4730","多项式函数":"10481","泰勒级数":"559","微分规则":"10482","逐项微分":"10483","级数":"10484","几何级数":"6916","切比雪夫多项式":"7252","首项系数":"5088","泰勒展开":"560","误差余项":"10485","e^x":"10486","复数":"5299","无理数":"575","代数数":"5207","映射(函数)":"1777","转置":"10487","集合":"4974","合成关系":"8647","几何代数":"6867","关系合成":"6737","整数集(Z)":"1307","子集":"5316","双曲几何":"8145","直线":"10488","互自切点(tacnode)":"5772","等边五边形":"10489","射线":"10490","凸五边形镶嵌":"6946","线段":"10491","法线":"557","矢":"10492","最值点":"1914","角平分线":"4497","圆":"5287","摆线":"1011","垂直平分线":"9407","同界角":"8745","五边形镶嵌":"5841","平行":"10493","四维柱体柱":"10494","旋转":"1450","可展曲面":"8450","球面几何":"4173","三维空间":"5160","二维空间":"5655","直纹曲面":"10495","一维空间":"10496","体积":"6120","长度":"5003","周长":"8925","对称轴":"10497","正方形":"3351","曲线":"581","立方体":"3962","垂直":"9402","克莱因瓶":"6458","相交":"10498","相切":"10499","相离":"10500","镜像":"10501","反演":"8296","表面积":"10502","挠率":"10503","角度":"4500","面积":"10504","离心率":"10505","三角函数表":"10506","正弦曲线":"3321","cis":"10507","三分之一角公式":"10508","三角函数恒等式":"10509","三角多项式":"10510","双曲三角函数":"8135","反三角函数":"5266","诱导公式":"10511","半正矢公式":"7714","三角函数精确值":"10512","高斯函数":"5098","三角函数积分表":"10513","双曲函数":"5270","三角函数线":"10514","有理函数":"491","无理函数":"677","正弦平方":"3319","割圆八线":"7393","余弦定理":"5214","圆心角":"9260","周期性":"8909","余函数恒等式":"6137","半正矢定理":"7715","精确值":"10515","余切":"6138","根号":"515","tan":"10516","近似作图":"10517","比例":"554","正弦":"3311","π":"10518","绝对误差":"10519","克莱姆法则":"6462","协方差矩阵":"7751","基":"5296","正交":"546","特征值":"5352","标量":"2624","向量子空间":"8819","特征向量":"5353","线性方程组":"4227","对偶空间":"10520","列空间":"7297","线性投影":"4222","矩阵中的项":"10521","双曲余弦函数":"8143","矩阵中的Q元素":"10522","偏导数":"5221","双曲正弦函数":"8161","Lax对":"10523","正弦函数":"544","复共轭矩阵":"9637","高维Lax对":"10524","本征值":"2311","李代数":"499","本征向量":"2312","费马小定理":"4606","幺正矩阵":"10525","极分解":"2417","方块矩阵":"10526","奇异值分解":"10527","二重向量":"5683","克利福德代数":"10528","幂零矩阵":"10529","LU分解":"10530","稀疏矩阵":"3936","行列式":"4419","格拉姆-施密特正交化":"2733","单位上三角矩阵":"7763","非奇异方阵":"10531","三角矩阵":"5154","伴随矩阵":"6040","反对称矩阵":"8263","可逆矩阵":"5277","埃尔米特矩阵":"9441","秩":"3910","外积":"10532","核":"2681","迹":"4938","线性空间":"4105","四元数":"9043","多重积分":"10533","左反函数":"10534","二阶可导的凸函数":"5691","一元函数":"5143","凸函数":"5245","二次函数":"5194","一元可微函数":"10535","二次可微函数":"5551","导数":"5329","凸集":"5246","绝对值函数":"4351","严格凸函数":"10536","半正定":"7711","极小值":"507","黑塞矩阵":"5056","函数限制":"7077","一对一函数":"10537","可测函数":"5275","光滑函数":"6404","复合函数":"9670","空间变换":"3958","非满射函数":"10538","方程式根":"1386","偏函数":"6260","恒等函数":"10539","连续函数":"4920"}


def get_skill_id(arg1,knowledges1,skill2id) -> dict:
    # 测试示例
    knowledge1 = arg1

    knowledges=knowledges1
    values_list = list(knowledges.values())
    # print(values_list)
    sim_list=[]
    for val in values_list:
        similarity, overlap_count, total_count = calculate_overlap(knowledge1, val)
        if(similarity>0):
            sim_list.append({
                "{}".format(str(similarity)):val
            })

    sorted_data = sorted(sim_list, key=lambda item: float(list(item.keys())[0]),reverse=True)
    if len(sorted_data):
        res=list(sorted_data[0].values())
        return {
            "result": skill2id[res[0]],
        }
    else:
        return {
            "result": "",
        }

# 连接数据库
conn = pymysql.connect(
    host='localhost',
    user='root',
    password='123456',
    database='dify'
)
import json

def process_path_questions(path_id, current_id):
    """
    根据path_id查询user_path_questions表对应的所有记录，
    并根据current_id确定这是第几条，将当前id及后面的id保存为候选列表
    同时根据相同逻辑拆分path_list
    
    Args:
        path_id (int): 路径ID
        current_id (int): 当前ID
    
    Returns:
        tuple: (questions_list, candidate_ids, completed_paths, remaining_paths)
    """
    
    # 查询user_path_questions表中指定path_id的所有记录
    query_questions = "SELECT * FROM user_path_questions WHERE path_id = %s ORDER BY id"
    questions_df = pd.read_sql(query_questions, conn, params=[path_id])
    
    # 将当前id及后面的id保存为候选列表
    candidate_ids = []
    completed_ids = []
    
    for idx, row in questions_df.iterrows():
        if row['id'] >= current_id:
            candidate_ids.append(row['id'])
        else:
            completed_ids.append(row['id'])
    
    # 查询learning_path表的path字段
    query_path = "SELECT path FROM learning_paths WHERE path_id = %s"
    path_df = pd.read_sql(query_path, conn, params=[path_id])
    
    completed_paths = []
    remaining_paths = []
    
    if not path_df.empty:
        # 将字符串转换为列表
        path_str = path_df.loc[0, 'path']
        try:
            path_list = json.loads(path_str)
        except json.JSONDecodeError:
            # 如果不是JSON格式，可能需要用eval或其他方式处理
            try:
                path_list = eval(path_str)
            except:
                path_list = [path_str]  # 作为fallback方案
        
        # 根据与candidate_ids相同的逻辑拆分path_list
        # 假设path_list的长度与questions_df的长度一致
        completed_count = len(completed_ids)
        
        # 拆分路径列表
        completed_paths = path_list[:completed_count] if completed_count > 0 else []
        remaining_paths = path_list[completed_count:]
    
    return questions_df, candidate_ids, completed_paths, remaining_paths

# 在你的代码中调用这个函数
# 示例用法：
questions_list, candidate_ids, completed_paths, remaining_paths = process_path_questions(path_id, id)
# print("问题列表:", questions_list)
# print("候选ID列表:", candidate_ids)
# print("已完成路径:", completed_paths)
# print("剩余路径:", remaining_paths)


# 读取原始数据（比如只处理今天的数据）
# query = f"SELECT * FROM user_skill_logs WHERE id >= {id} limit {row}"
# print(query)
# df = pd.read_sql(query, conn)
# print(type(df))
# print(df)






# res=main()
# # print(res)

# # def calculate_mastery():
# #     return 0
# #


# 构建已完成路径的字符串
completed_str = "\n".join([f"{i+1}. {path}" for i, path in enumerate(completed_paths)])
if not completed_str:
    completed_str = "无"
    
# 构建剩余路径的字符串
remaining_str = "\n".join([f"{i+1}. {path}" for i, path in enumerate(remaining_paths)])
if not remaining_str:
    remaining_str = "无"
    
# prompt = f"""
# 你是一个专业的学习路径动态规划师。目前学生正在学习的知识点，已经学习多次，但都未通过。你需要重新规划更符合学生学习能力的新学习路径，下方为具体的知识信息。

# 学生学习过多次但并未掌握的知识点: {skill}

# 已完成的学习内容:
# {completed_str}

# 请根据以上信息，针对未掌握的知识点为学生制定一个有效的学习计划。在规划学习路径时，请确保路径中不包含学生已掌握的知识点（如“{completed_str}”），并从前置知识开始，逐步过渡到对应的知识点，主要是要对知识点（{str(remaining_paths[0])}）进行细致拆分和规划,并且规划出来的路径必须要和后续的知识点{str(remaining_paths[1:])}保持连贯性。
# 请为每个学习阶段提供具体的学习资源类型（从视频资源、课件资源、论文资源、练习资源中选择最合适的一种）、学习方法和补充建议。\n
# """
# prompt2="""请严格按照以下JSON格式输出，不要包含任何其他内容:

# {
#   "learning": "视频资源|课件资源|论文资源|练习资源",
#   "plan": ["知识点1", "知识点2", ...],
#   "detail": [
#     {
#       "topic": "知识点名称",
#       "hours": 整数,
#       "method": "建议的学习方法",
#       "notes": "补充说明或建议"
#     },
#     ...
#   ]
# }\n
# """
# prompt3="""
# 注意事项:
# 1. "learning"字段必须严格按照"视频资源|课件资源|论文资源|练习资源"格式，从四种资源类型中选择最核心的一种，不要列出多种。
# 2. "plan"字段是重新规划的知识点列表，应从前置知识（但非已学内容）到目标知识循序渐进，不包含已掌握的知识点，内容只能是知识点字符串，不能嵌套列表和对象，。
# 3. "detail"字段详细描述每个知识点的学习安排，包括学习时长、方法和建议。
# 4. 重点关注第一个未掌握的知识点（{}），将其细化为多个子知识点并提供细致的学习建议。
# 5. 输出必须是严格的JSON格式，不包含任何其他文字、解释或标记。
# 6. 不要使用任何markdown格式或其他装饰性内容。
# 7. 学习计划必须具体、可行，且完全聚焦于未掌握的知识点，避免重复已学内容。
# """.format(str(remaining_paths[0]))


prompt=f"""
你是一个专业的学习路径动态规划师。学生在某个知识点上遇到了学习困难，需要你分析其学习障碍并重新设计更适合的学习路径。
学生当前状况分析

已完成的知识点:{completed_str}
学习困难的知识点: {skill}
后续课程要求: {remaining_str}

重新规划要求
核心原则: 既然学生多次学习仍未掌握，说明原有学习路径的知识点安排存在问题。你需要：

重新选择知识点 - 选择不同的知识点来构建学习路径
确保知识衔接 - 新选择的知识点必须与学生已掌握的知识点有良好的衔接
调整学习顺序 - 重新安排知识点的学习顺序，使其更符合认知规律
创新学习顺序 - 采用全新的知识点学习顺序，避免重复原有的规划思路

禁止使用原有学习规划中的知识点（包括已规划但未开始学习的内容）
禁止重复学生已经完成的知识点
禁止选择与已学知识点无法良好衔接的内容
禁止跳跃式规划，缺乏渐进性

具体规划要求
请针对学习困难的知识点重新选择合适的学习路径：

前置知识分析 - 基于学生已掌握的知识点，选择能够良好衔接的新知识点
知识点替换 - 用不同的知识点来构建通往目标知识的路径
顺序重组 - 重新安排知识点学习顺序，确保逻辑连贯
衔接优化 - 确保新选择的知识点能够顺利连接到后续知识点
"""
prompt2="""输出格式要求
请严格按照以下JSON格式输出，不要包含任何其他内容：
json{
  "plan": ["知识点1", "知识点2", "知识点3", ...],
  "detail": [
    {
      "topic": "知识点名称",
      "hours": 整数,
      "method": "具体的学习方法描述",
      "notes": "针对学习困难的特别建议"
    }
  ]
}
格式说明

plan: 重新选择的知识点序列，必须与原有知识点有显著区别且能良好衔接
detail: 每个知识点的详细学习安排

质量检查标准

新选择的知识点是否与学生已尝试的知识点不同？
知识点之间是否有良好的逻辑衔接关系？
新路径是否能从已掌握的知识点自然过渡？
整体路径是否能有效衔接到后续课程？

"""

def build_improved_prompt(completed_paths, skill, remaining_paths):
    """
    构建改进的prompt，明确列出要避免的知识点
    """
    completed_str = "\n".join([f"{i+1}. {path}" for i, path in enumerate(completed_paths)])
    if not completed_str:
        completed_str = "无"
    
    # 明确列出原有规划中的所有知识点（这些都要避免）
    original_plan_str = "\n".join([f"{i+1}. {path}" for i, path in enumerate(remaining_paths)])
    
    prompt = f"""
你是一个专业的学习路径动态规划师。学生在某个知识点上遇到了学习困难，需要你重新设计完全不同的学习路径。

## 学生当前状况分析
- 已完成的知识点: {completed_str}
- 学习困难的知识点: {skill}
- 原有学习规划（必须避免的知识点）: 
{original_plan_str}

## 严格要求
**绝对禁止使用以下知识点（这些是原有规划，必须完全避免）：**
{chr(10).join([f"❌ {path}" for path in remaining_paths])}

**必须要求：**
1. 生成的所有知识点都不能出现在上述禁止列表中
2. 必须选择完全不同的知识点来构建学习路径
3. 新知识点必须与已完成知识点有良好衔接
4. 最终能够达到学习困难知识点：{skill}

## 重新规划要求
**核心原则**: 既然学生多次学习仍未掌握，说明原有学习路径的知识点安排存在问题。你需要：

1. **完全重新设计** - 选择与原有规划完全不同的知识点来构建学习路径
2. **确保知识衔接** - 新选择的知识点必须与学生已掌握的知识点有良好的衔接
3. **创新学习顺序** - 采用全新的知识点学习顺序，避免重复原有的规划思路

**严格禁止**: 
- 重复学生已经完成的知识点
- 使用原有学习规划中的知识点（包括已规划但未开始学习的内容）
- 选择与已学知识点无法良好衔接的内容
- 跳跃式规划，缺乏渐进性

## 具体规划要求
请针对学习困难的知识点重新选择合适的学习路径：

1. **前置知识分析** - 基于学生已掌握的知识点，选择能够良好衔接的新知识点
2. **知识点替换** - 用不同的知识点来构建通往目标知识的路径
3. **顺序重组** - 重新安排知识点学习顺序，确保逻辑连贯
4. **衔接优化** - 确保新选择的知识点能够顺利连接到后续知识点

## 输出格式要求
请严格按照以下JSON格式输出，不要包含任何其他内容：

```json
{{
  "plan": ["知识点1", "知识点2", "知识点3", ...],
  "detail": [
    {{
      "topic": "知识点名称",
      "hours": 整数,
      "method": "具体的学习方法描述",
      "notes": "针对学习困难的特别建议"
    }}
  ]
}}
```

## 格式说明
- **plan**: 完全重新设计的知识点序列，必须与原有规划和已尝试的知识点都有显著区别且能良好衔接
- **detail**: 每个知识点的详细学习安排

## 质量检查标准
1. 新选择的知识点是否与学生已尝试的知识点完全不同？
2. 新路径是否与原有学习规划中的知识点完全不同？
3. 知识点之间是否有良好的逻辑衔接关系？
4. 新路径是否能从已掌握的知识点自然过渡？
5. 整体路径是否能有效衔接到后续课程？

**重要提醒：生成的plan中的任何知识点都不能包含：{', '.join(remaining_paths)}**
"""
    return prompt




def update_learning_path(path_id, new_path_list):
    """
    根据path_id更新learning_paths表的path字段
    
    Args:
        path_id (int): 路径ID
        new_path_list (list): 新的路径列表
    
    Returns:
        bool: 更新成功返回True，否则返回False
    """
    try:
        # 将列表转换为JSON字符串
        import json
        path_json = json.dumps(new_path_list, ensure_ascii=False)
        
        # 更新learning_paths表
        with conn.cursor() as cursor:
            sql = "UPDATE learning_paths SET path = %s WHERE path_id = %s"
            cursor.execute(sql, (path_json, path_id))
            conn.commit()
            
            # 检查是否有行被更新
            if cursor.rowcount > 0:
                return True
            else:
                return False
                
    except Exception as e:
        print(f"❌ 更新学习路径失败: {e}")
        conn.rollback()
        return False

# 使用示例:
# new_path = ["基础概念", "进阶应用", "实战演练"]
# update_learning_path(path_id, new_path)
def extract_json_objects(text):
        json_objects = []

        # 1. 提取 JSON 片段
        matches = re.findall(r'```json\s*([\s\S]*?)```', text, re.DOTALL)


        # 2. 修复并解析每个 JSON 片段
        for match in matches:
            try:
                # 使用 json_repair 修复 JSON 字符串
                repaired = repair_json(match.strip())
                parsed = json.loads(repaired)  # 转为 Python 对象
                json_objects.append(parsed)
            except json.JSONDecodeError as e:
                print(f"修复后仍解析失败: {
              e}")
                print("原始内容:\n", match)
                print("修复后内容:\n", repaired)
            except Exception as ex:
                print(f"未知错误: {
              ex}")

        return json_objects


# final_prompt = prompt+prompt2+prompt3
final_prompt = build_improved_prompt(completed_paths,skill,remaining_paths)
# print(prompt+prompt2+prompt3)

import re
# Ollama API 地址
url = "http://localhost:11434/api/generate"

# 请求数据
data = {
    "model": "MAGIC_final_deepseek_r1_7b:latest",  # 替换为你本地已加载的模型名称，如 llama3、mistral 等
    "prompt": final_prompt,
    "stream": False  # 设置为 False 表示不使用流式输出
}


import requests
import json

def get_questions_by_skill_id(skill_id):
    """
    根据skill_id获取问题列表
    
    Args:
        skill_id (int or str): 技能ID
        
    Returns:
        dict: 接口返回的数据
    """
    # 构建请求URL
    url = f"http://localhost:3000/api/get-questions-by_skill_id/{skill_id}"
    
    try:
        # 发送GET请求
        response = requests.get(url)
        
        # 检查响应状态码
        if response.status_code == 200:
            # 解析JSON响应
            data = response.json()
            return data
        else:
            print(f"请求失败，状态码: {response.status_code}")
            print(f"错误信息: {response.text}")
            return None
            
    except requests.exceptions.RequestException as e:
        print(f"请求发生异常: {e}")
        return None

    
   

# 发送 POST 请求
response = requests.post(url, json=data)
if response.status_code == 200:
    result = response.json()
    # print(result.get("response", ""))
    cleaned_res=re.sub(r"<think>.*?</think>", "",result.get("response", ""), flags=re.DOTALL).strip()
    # print(cleaned_res)
    res=extract_json_objects(cleaned_res)
    # print(type(res[0]["plan"]))
    plan_list = []
    if isinstance(res[0]["plan"], list):
        plan_list = res[0]["plan"]
    else:
        plan_list = [res[0]["plan"]]
    excluded_paths = set(completed_paths + remaining_paths[1:])
    
    # 分离需要保留和需要移除的项目
    filtered_plan_list = []
    removed_items = []
    
    for plan in plan_list:
        if plan not in excluded_paths:
            filtered_plan_list.append(plan)
        else:
            removed_items.append(plan)
    # print(plan_list)
    # print(plan_list)
    final_plan = completed_paths + filtered_plan_list + remaining_paths[1:]
    # print(final_plan)
    result_json={
        "llm_output":result.get("response", ""),
        "completed_paths": completed_paths,
        "remaining_paths": remaining_paths[1:],
        "final_plan": final_plan,
        "candidate_ids":candidate_ids,
        "original_plan":plan_list,
        "new_plan_list":filtered_plan_list,
    }
    print(json.dumps(result_json, ensure_ascii=False))
